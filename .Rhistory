#' @author Gabriel Gaona
#' @param destmat  matrix, datat.frame or tibble of target points 2D or 3D
#' @param centre Numeric. Coordinates 2D or 3D of central point.
#' @details Given a matriz of xy or xyz coordinates for a set of point locations
#'   compute the euclidean distances from a centre coordinate. This can be used
#'   in a planar coordinate system (e.g. projected coordinates in UTM)
#' @return Depends on input, returns a Numeric vector of distances to each
#'   location from the specified centre.
#' @importFrom splancs gridpts
#'
distances <- function(destmat, centre = NULL) {
# Control for few centre coordiantes
if(!is.null(centre) | length(centre) < 2) {
stop("Centre must be a c(x, y) or c(x, y, z) vector")
}
# Control for to many centre coordiantes
if(!is.null(centre) | length(centre) > 2) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
centre <- unlist(centre)[1:3]
}
# Control for few destmat coordiantes
if(ncol(destmat) < 2) {
stop("'destmat' must be of class matrix, data.frame or tibble with x,y or x, y, z columns")
}
# Control for to many destmat coordiantes
if(ncol(destmat) > 3) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
destmat <- destmat[,1:3]
}
# Control for centre == null
if(is.null(centre)) {
warning("Centre  == NULL. Calculating mean_centre from input locations")
centre <- mean_centre(desmat)
}
# Control for same dimensions in centre and destmat
if(ncol(destmat) != length(centre)) {
if(ncol(destmat) < length(centre)) {
centre <- centre[1:2]
warning("More 'centre' dimensions than 'destmat'. Extra dimensions droped...")
} else {
destmat <- destmat[,1:2]
warning("More 'destmat' dimensions than 'centre'. Extra dimensions droped...")
}
centre <- unlist(centre)
# Compute euclidean distance
sq = destmat
i = 1
while(i <= length(centre)){
sq[[i]] <- (sq[[i]] - centre[i]) ^ 2
i = i + 1
}
di <- sqrt(rowSums(sq))
names(di) <- NULL
# PROVIDE THE VECTOR OF DISTANCES, di, AS A RETURN PARAMETER TO THE CALLING FUNCTION
return(di)
}
distances(tmp)
tmp <- cbind(aspace::activities, sample(500:1000, 10, replace = TRUE))
names(tmp) <- c("x", "y", "z")
distances(tmp)
#' @author Gabriel Gaona
#' @param destmat  matrix, datat.frame or tibble of target points 2D or 3D
#' @param centre Numeric. Coordinates 2D or 3D of central point.
#' @details Given a matriz of xy or xyz coordinates for a set of point locations
#'   compute the euclidean distances from a centre coordinate. This can be used
#'   in a planar coordinate system (e.g. projected coordinates in UTM)
#' @return Depends on input, returns a Numeric vector of distances to each
#'   location from the specified centre.
#' @importFrom splancs gridpts
#'
distances <- function(destmat, centre = NULL) {
# Control for few centre coordiantes
if(!is.null(centre) & length(centre) < 2) {
stop("Centre must be a c(x, y) or c(x, y, z) vector")
}
# Control for to many centre coordiantes
if(!is.null(centre) & length(centre) > 2) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
centre <- unlist(centre)[1:3]
}
# Control for few destmat coordiantes
if(ncol(destmat) < 2) {
stop("'destmat' must be of class matrix, data.frame or tibble with x,y or x, y, z columns")
}
# Control for to many destmat coordiantes
if(ncol(destmat) > 3) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
destmat <- destmat[,1:3]
}
# Control for centre == null
if(is.null(centre)) {
warning("Centre  == NULL. Calculating mean_centre from input locations")
centre <- mean_centre(desmat)
}
# Control for same dimensions in centre and destmat
if(ncol(destmat) != length(centre)) {
if(ncol(destmat) < length(centre)) {
centre <- centre[1:2]
warning("More 'centre' dimensions than 'destmat'. Extra dimensions droped...")
} else {
destmat <- destmat[,1:2]
warning("More 'destmat' dimensions than 'centre'. Extra dimensions droped...")
}
centre <- unlist(centre)
# Compute euclidean distance
sq = destmat
i = 1
while(i <= length(centre)){
sq[[i]] <- (sq[[i]] - centre[i]) ^ 2
i = i + 1
}
di <- sqrt(rowSums(sq))
names(di) <- NULL
# PROVIDE THE VECTOR OF DISTANCES, di, AS A RETURN PARAMETER TO THE CALLING FUNCTION
return(di)
}
distances(tmp)
devtools::load_all(".")
distances(tmp)
#' @author Gabriel Gaona
#' @param destmat  matrix, datat.frame or tibble of target points 2D or 3D
#' @param centre Numeric. Coordinates 2D or 3D of central point.
#' @details Given a matriz of xy or xyz coordinates for a set of point locations
#'   compute the euclidean distances from a centre coordinate. This can be used
#'   in a planar coordinate system (e.g. projected coordinates in UTM)
#' @return Depends on input, returns a Numeric vector of distances to each
#'   location from the specified centre.
#' @importFrom splancs gridpts
#'
distances <- function(destmat, centre = NULL) {
# Control for few centre coordiantes
if(!is.null(centre) & length(centre) < 2) {
stop("Centre must be a c(x, y) or c(x, y, z) vector")
}
# Control for to many centre coordiantes
if(!is.null(centre) & length(centre) > 2) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
centre <- unlist(centre)[1:3]
}
# Control for few destmat coordiantes
if(ncol(destmat) < 2) {
stop("'destmat' must be of class matrix, data.frame or tibble with x,y or x, y, z columns")
}
# Control for to many destmat coordiantes
if(ncol(destmat) > 3) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
destmat <- destmat[,1:3]
}
# Control for centre == null
if(is.null(centre)) {
warning("Centre  == NULL. Calculating mean_centre from input locations")
centre <- mean_centre(destmat)
}
# Control for same dimensions in centre and destmat
if(ncol(destmat) != length(centre)) {
if(ncol(destmat) < length(centre)) {
centre <- centre[1:2]
warning("More 'centre' dimensions than 'destmat'. Extra dimensions droped...")
} else {
destmat <- destmat[,1:2]
warning("More 'destmat' dimensions than 'centre'. Extra dimensions droped...")
}
centre <- unlist(centre)
# Compute euclidean distance
sq = destmat
i = 1
while(i <= length(centre)){
sq[[i]] <- (sq[[i]] - centre[i]) ^ 2
i = i + 1
}
di <- sqrt(rowSums(sq))
names(di) <- NULL
# PROVIDE THE VECTOR OF DISTANCES, di, AS A RETURN PARAMETER TO THE CALLING FUNCTION
return(di)
}
distances(tmp)
distances(tmp[,-3], centre = mean_centre(tmp[,-3]))
distances(tmp[,-3], centre = mean_centre(tmp[,3]))
distances(tmp[,1], centre = mean_centre(tmp[,-3]))
distances(tmp[,1:2], centre = mean_centre(tmp[,-3]))
distances(tmp, centre = mean_centre(tmp))
distances(tmp)
distances(tmp, centre = mean_centre(tmp))
#' @author Gabriel Gaona
#' @param destmat  matrix, datat.frame or tibble of target points 2D or 3D
#' @param centre Numeric. Coordinates 2D or 3D of central point.
#' @details Given a matriz of xy or xyz coordinates for a set of point locations
#'   compute the euclidean distances from a centre coordinate. This can be used
#'   in a planar coordinate system (e.g. projected coordinates in UTM)
#' @return Depends on input, returns a Numeric vector of distances to each
#'   location from the specified centre.
#' @importFrom splancs gridpts
#'
distances <- function(destmat, centre = NULL) {
# Control for few centre coordiantes
if(!is.null(centre) & length(centre) < 2) {
stop("Centre must be a c(x, y) or c(x, y, z) vector")
}
# Control for to many centre coordiantes
if(!is.null(centre) & length(centre) > 3) {
warning("'centre' more than 3 columns. Only first three columns are being used as xyz coordinates")
centre <- unlist(centre)[1:3]
}
# Control for few destmat coordiantes
if(ncol(destmat) < 2) {
stop("'destmat' must be of class matrix, data.frame or tibble with x,y or x, y, z columns")
}
# Control for to many destmat coordiantes
if(ncol(destmat) > 3) {
warning("'desmat' more than 3 columns. Only first three columns are being used as xyz coordinates")
destmat <- destmat[,1:3]
}
# Control for centre == null
if(is.null(centre)) {
warning("Centre  == NULL. Calculating mean_centre from input locations")
centre <- mean_centre(destmat)
}
# Control for same dimensions in centre and destmat
if(ncol(destmat) != length(centre)) {
if(ncol(destmat) < length(centre)) {
centre <- centre[1:2]
warning("More 'centre' dimensions than 'destmat'. Extra dimensions droped...")
} else {
destmat <- destmat[,1:2]
warning("More 'destmat' dimensions than 'centre'. Extra dimensions droped...")
}
centre <- unlist(centre)
# Compute euclidean distance
sq = destmat
i = 1
while(i <= length(centre)){
sq[[i]] <- (sq[[i]] - centre[i]) ^ 2
i = i + 1
}
di <- sqrt(rowSums(sq))
names(di) <- NULL
# PROVIDE THE VECTOR OF DISTANCES, di, AS A RETURN PARAMETER TO THE CALLING FUNCTION
return(di)
}
distances(tmp, centre = mean_centre(tmp))
distances(tmp)
central_feature(tmp)
central_feature(tmp[,-3])
median_centre(tmp)
central_feature2pts(tmp[,-3], aspace::activities2)
#' @export
#' @rdname central_feature2pts
central_feature2pts <- function(points = activities, points2 = activities2) {
# Control for few columns in points
if(ncol(points) < 2) {
stop("'points' must be of class matrix, data.frame or tibble with 2 or 3 numeric columns")
}
# Control for few columns in points2
if(ncol(points2) < 2) {
stop("'points2' must be of class matrix, data.frame or tibble with 2 or 3 numeric columns")
}
# Control for to many columns in points
if(ncol(points) > 3) {
warning("'points' more than 3 columns. Only first three columns are being used as xyz coordinates")
points <- points[,1:3]
}
# Control for to many columns in points2
if(ncol(points2) > 3) {
warning("'points2' more than 3 columns. Only first three columns are being used as xyz coordinates")
points2 <- points2[,1:3]
}
# Control for same size in points and points2
if(ncol(points) != ncol(points2)) {
if(ncol(points) > ncol(points2)) {
points <- points[,1:2]
warning("More dimensions in 'points' than 'points2'. Extra dimensions droped...")
} else {
points2 <- points2[,1:2]
warning("More dimensions in 'points2' than 'points'. Extra dimensions droped...")
}
# Central feature between two point patterns
d <- vector("numeric", nrow(points2))
i = 1
while(i <= nrow(points2)){
d[i] <- sum(distances(destmat = points, centre = points2[i,]))
i = i + 1
}
unlist(points2[which.min(d),])
}
central_feature2pts(tmp[,-3], aspace::activities2)
library(aspace2)
central_feature2pts(tmp[,-3], aspace::activities2)
calc_sde(tmp)
calc_sde(tmp[-3])
calc_box(tmp[-3])
calc_box(tmp)
sd_box(tmp)
devtools::load_all(".")
sd_box(tmp)
sd_distance(tmp)
devtools::load_all(".")
sd_distance(tmp)
sd_distance(tmp[,-3])
devtools::load_all(".")
sd_distance(tmp)
devtools::load_all(".")
sd_distance(tmp)
devtools::build()
devtools::document()
devtools::load_all(".")
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
devtools::document()
library(aspace2)
